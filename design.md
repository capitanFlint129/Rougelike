## general information about the system;
Игра представляет собой консольную игру RogueLike, разработанную на Python. Игрок управляет отважным мальчиком, который отправляется в опасное приключение в пещеру, чтобы спасти принцессу(сестру?ну тип что не повторяться), которая, как говорят, находится там в плену. Карта игры генерируется случайным образом, но некоторые уровни загружаются из файлов. У персонажа игрока есть такие характеристики, как здоровье и сила атаки, которые влияют на игровой процесс. У игрока есть инвентарь предметов, которые можно подобрать с карты и использовать для улучшения характеристик персонажа. В игре представлены бои, основанные на стрельбе, против монстров, которые также могут стрелять в ответ. Карта состоит из коридоров с комнатами, в которых могут быть ловушки, враги, снаряжение и комната с боссом. Графика игры традиционна для жанра RogueLike и представлена в виде символов консоли.

## architectural drivers

- Простота кода: код должен быть простым и легко читаемым, с хорошо организованными и модульными компонентами, чтобы его было легче поддерживать и модифицировать с течением времени.

- Процедурная генерация: Алгоритмы процедурной генерации следует использовать для генерации случайных карт, врагов и снаряжения. Эти алгоритмы должны быть эффективными и давать интересные и разнообразные результаты для того, чтобы игровой процесс отличался от предыдущих игровых сессий.

- Баланс: случайно сгенерированный контент должен быть сбалансирован и не ставить игрока несправедливо в невыгодное положение. Сложность врагов и редкость снаряжения должны быть откалиброваны, чтобы обеспечить честный и приятный игровой процесс.

- Совместимость с платформами: игра должна быть разработана для работы на нескольких платформах, включая Windows, Linux и macOS, с минимальными изменениями.

## роли 

Игрок: игрок является основным пользователем игры, управляющим персонажем главного героя и перемещающимся по игровому миру.

Разработчик игры: Разработчик игры отвечает за создание, обслуживание и обновление игрового программного обеспечения и контента.

## случаи использования

Игрок запускает игру в консоли и пытается пройти как можно дальше по случайно сгенерированному игровому миру, перемещая персонажа, участвуя в бою и управляя инвентарем. (???)

## описание типичного пользователя

Типичный пользователь этой игры — казуальный геймер, которому нравятся приключенческие игры с элементами стрельбы. Скорее всего, им от 12 до 35 лет, и у них есть некоторый игровой опыт. Они ищут игру, которая предлагает сложный и увлекательный опыт, но в то же время ее легко освоить и играть. Они также могут быть заинтересованы в изучении случайно сгенерированных сред и обнаружении новых вещей для персонажа и врагов в каждом прохождении.

## композиция (диаграмма компонентов и её текстовое описание);

@startuml

skin rose

title RogueLike Game - Component Diagram

component [Game\nEngine] as GE

@enduml

## Логическая структура
Диаграмма классов:

![](.\docs\class.png)

### GameEngine
Класс, который отвечает за организацию игрового процесса. Он хранит экземпляр 
класса State и список контроллеров. GameEngine последовательно вызывает 
метод updateState каждого контроллера, чтобы он обновил State. 
В конце обновленный State передается в Gui, для отображения актуального состояния
пользователю. В случае же, если пользователь желает открыть инвентарь данный класс
передает управление в InventoryMenu.

### State
Класс, хранящий текущее состояние игрового поля. Хранит
всех Actor и Item, а также их координаты в комнате.

### Gui
Интерфейс определяющий методы для отрисовки текущего состояния игры и инвентаря.  

### ConsoleGui
Реализация Gui через консольную графику. Может отрисовывать GameObject.

### CommandsHandler
Класс обрабатывающий пользовательский ввод. Дает остальным классам доступ к тому, 
что нажал пользователь.

### GameObject
Абстрактный класс для интерактивных объектов на игровом поле.

### Actor
Абстрактный класс для существ, у которых есть атака, здоровье, инвентарь. Они могут
наносить урон и получать его.

### Player
Класс игрока. Наследуется от Actor.

### Enemy
Абстрактный класс для врагов. Наследуется от Actor. Определяет то, как двигается конкретный враг, 
через метод move.

### Destination
Структура, описывающая координаты, куда хочет переместиться враг. Возвращается из move.

### Item
Абстрактный класс для объектов, которые могут быть в инвентаре у Actor. Наследуется от GameObject.

### Controller
Интерфейс определяющий метод для изменения State. 

### PlayerController
Класс определяющий то, как игрок меняет State, в том числе нанесение урона, движение, поднятие предметов.

### EnemyController
Класс определяющий то, как противники меняют State, в том числе нанесение урона, движение.
В частности, EnemyController получает из метода move желаемое направление движения конкретного
врага и производит изменения State в соответствии с ним в зависимости от того, есть
ли препятствие на пути врага, может ли он атаковать сейчас и так далее. 

### WorldController
Класс определяющий то, как State меняется из-за перехода игрока в новую область. В частности
отвечает за загрузку в State уже посещенной комнаты, если игрок 
возвращается обратно, и за генерацию новой комнаты, если игрок переходит в новую комнату.

### ItemGenerator
Класс, отвечающий за то, какие предметы лежат в новой комнате.

### EnemyGenerator
Класс, отвечающий за то, какие враги находятся в новой комнате.

### MapGenerator
Класс, отвечающий за создание новой комнаты.

### InventoryMenu
Класс отвечающий за взаимодействие игрока с инвентарем, то есть за выбор предметов в меню.


## Взаимодействия и состояния
Диаграмма последовательностей:

![](.\docs\sequence.png)

На данной диаграмме отображен сценарий, когда игрок атакует противника, после чего 
противники идут в сторону игрока.

1. Когда пользователь запускает игру, запускается класс GameEngine
2. Игрок нажимает на кнопку перемещения
3. Когда GameEngine начинает обработку итерации игры, определяется, что команда от пользователя
относится к управлению персонажем (а не к открытию меню)
4. Последовательно запускаются контроллеры
5. PlayerController:
   1. определяет команду пользователя
   2. по State определяет, что на его пути находится враг 
   3. получает значение атаки игрока, которое определяется с учетом надетого снаряжения
   4. применяет атаку к стоящему на пути игрока врагу
6. EnemiesController:
   1. Определяет позицию игрока
   2. Для каждого врага определяет направление его движения и перемещает его в соответствии с окружением
7. WorldController определяет, что игрок не взаимодействует с дверями, поэтому ничего не делает
8. Получив обновленный State, GameEngine передает его ConsoleGui, который отрисовывает актуальное
состояние игрового поля